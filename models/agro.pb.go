// Code generated by protoc-gen-gogo.
// source: agro.proto
// DO NOT EDIT!

/*
	Package models is a generated protocol buffer package.

	It is generated from these files:
		agro.proto
		rpc.proto

	It has these top-level messages:
		INode
		BlockLayer
		Volume
		PeerInfo
		RebalanceInfo
		Ring
		BlockRef
		INodeRef
		BlockRequest
		BlockResponse
		PutBlockRequest
		PutResponse
		RebalanceCheckRequest
		RebalanceCheckResponse
*/
package models

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type INode struct {
	Volume   uint64            `protobuf:"varint,1,opt,name=volume,proto3" json:"volume,omitempty"`
	INode    uint64            `protobuf:"varint,2,opt,name=inode,proto3" json:"inode,omitempty"`
	Filesize uint64            `protobuf:"varint,4,opt,name=filesize,proto3" json:"filesize,omitempty"`
	Attrs    map[string]string `protobuf:"bytes,7,rep,name=attrs" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Blocks   []*BlockLayer     `protobuf:"bytes,8,rep,name=blocks" json:"blocks,omitempty"`
}

func (m *INode) Reset()         { *m = INode{} }
func (m *INode) String() string { return proto.CompactTextString(m) }
func (*INode) ProtoMessage()    {}

func (m *INode) GetAttrs() map[string]string {
	if m != nil {
		return m.Attrs
	}
	return nil
}

func (m *INode) GetBlocks() []*BlockLayer {
	if m != nil {
		return m.Blocks
	}
	return nil
}

type BlockLayer struct {
	Type    uint32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *BlockLayer) Reset()         { *m = BlockLayer{} }
func (m *BlockLayer) String() string { return proto.CompactTextString(m) }
func (*BlockLayer) ProtoMessage()    {}

type Volume struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Id   uint64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	Type string `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	// TODO(barakmich): Respect sizes for FILE volumes.
	MaxBytes uint64 `protobuf:"varint,4,opt,name=max_bytes,proto3" json:"max_bytes,omitempty"`
}

func (m *Volume) Reset()         { *m = Volume{} }
func (m *Volume) String() string { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()    {}

type PeerInfo struct {
	UUID          string         `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	Address       string         `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	LastSeen      int64          `protobuf:"varint,3,opt,name=last_seen,proto3" json:"last_seen,omitempty"`
	TotalBlocks   uint64         `protobuf:"varint,4,opt,name=total_blocks,proto3" json:"total_blocks,omitempty"`
	UsedBlocks    uint64         `protobuf:"varint,5,opt,name=used_blocks,proto3" json:"used_blocks,omitempty"`
	TimedOut      bool           `protobuf:"varint,6,opt,name=timed_out,proto3" json:"timed_out,omitempty"`
	RebalanceInfo *RebalanceInfo `protobuf:"bytes,7,opt,name=rebalance_info" json:"rebalance_info,omitempty"`
}

func (m *PeerInfo) Reset()         { *m = PeerInfo{} }
func (m *PeerInfo) String() string { return proto.CompactTextString(m) }
func (*PeerInfo) ProtoMessage()    {}

func (m *PeerInfo) GetRebalanceInfo() *RebalanceInfo {
	if m != nil {
		return m.RebalanceInfo
	}
	return nil
}

type RebalanceInfo struct {
	LastRebalanceFinish int64  `protobuf:"varint,1,opt,name=last_rebalance_finish,proto3" json:"last_rebalance_finish,omitempty"`
	LastRebalanceBlocks uint64 `protobuf:"varint,2,opt,name=last_rebalance_blocks,proto3" json:"last_rebalance_blocks,omitempty"`
	Rebalancing         bool   `protobuf:"varint,3,opt,name=rebalancing,proto3" json:"rebalancing,omitempty"`
}

func (m *RebalanceInfo) Reset()         { *m = RebalanceInfo{} }
func (m *RebalanceInfo) String() string { return proto.CompactTextString(m) }
func (*RebalanceInfo) ProtoMessage()    {}

type Ring struct {
	Type              uint32            `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Version           uint32            `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	ReplicationFactor uint32            `protobuf:"varint,3,opt,name=replication_factor,proto3" json:"replication_factor,omitempty"`
	Peers             []*PeerInfo       `protobuf:"bytes,4,rep,name=peers" json:"peers,omitempty"`
	Attrs             map[string][]byte `protobuf:"bytes,5,rep,name=attrs" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Ring) Reset()         { *m = Ring{} }
func (m *Ring) String() string { return proto.CompactTextString(m) }
func (*Ring) ProtoMessage()    {}

func (m *Ring) GetPeers() []*PeerInfo {
	if m != nil {
		return m.Peers
	}
	return nil
}

func (m *Ring) GetAttrs() map[string][]byte {
	if m != nil {
		return m.Attrs
	}
	return nil
}

type BlockRef struct {
	Volume uint64 `protobuf:"varint,1,opt,name=volume,proto3" json:"volume,omitempty"`
	INode  uint64 `protobuf:"varint,2,opt,name=inode,proto3" json:"inode,omitempty"`
	Block  uint64 `protobuf:"varint,3,opt,name=block,proto3" json:"block,omitempty"`
}

func (m *BlockRef) Reset()         { *m = BlockRef{} }
func (m *BlockRef) String() string { return proto.CompactTextString(m) }
func (*BlockRef) ProtoMessage()    {}

type INodeRef struct {
	Volume uint64 `protobuf:"varint,1,opt,name=volume,proto3" json:"volume,omitempty"`
	INode  uint64 `protobuf:"varint,2,opt,name=inode,proto3" json:"inode,omitempty"`
}

func (m *INodeRef) Reset()         { *m = INodeRef{} }
func (m *INodeRef) String() string { return proto.CompactTextString(m) }
func (*INodeRef) ProtoMessage()    {}

func init() {
	proto.RegisterType((*INode)(nil), "models.INode")
	proto.RegisterType((*BlockLayer)(nil), "models.BlockLayer")
	proto.RegisterType((*Volume)(nil), "models.Volume")
	proto.RegisterType((*PeerInfo)(nil), "models.PeerInfo")
	proto.RegisterType((*RebalanceInfo)(nil), "models.RebalanceInfo")
	proto.RegisterType((*Ring)(nil), "models.Ring")
	proto.RegisterType((*BlockRef)(nil), "models.BlockRef")
	proto.RegisterType((*INodeRef)(nil), "models.INodeRef")
}
func (this *INode) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*INode)
	if !ok {
		that2, ok := that.(INode)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *INode")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *INode but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *INode but is not nil && this == nil")
	}
	if this.Volume != that1.Volume {
		return fmt.Errorf("Volume this(%v) Not Equal that(%v)", this.Volume, that1.Volume)
	}
	if this.INode != that1.INode {
		return fmt.Errorf("INode this(%v) Not Equal that(%v)", this.INode, that1.INode)
	}
	if this.Filesize != that1.Filesize {
		return fmt.Errorf("Filesize this(%v) Not Equal that(%v)", this.Filesize, that1.Filesize)
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return fmt.Errorf("Attrs this(%v) Not Equal that(%v)", len(this.Attrs), len(that1.Attrs))
	}
	for i := range this.Attrs {
		if this.Attrs[i] != that1.Attrs[i] {
			return fmt.Errorf("Attrs this[%v](%v) Not Equal that[%v](%v)", i, this.Attrs[i], i, that1.Attrs[i])
		}
	}
	if len(this.Blocks) != len(that1.Blocks) {
		return fmt.Errorf("Blocks this(%v) Not Equal that(%v)", len(this.Blocks), len(that1.Blocks))
	}
	for i := range this.Blocks {
		if !this.Blocks[i].Equal(that1.Blocks[i]) {
			return fmt.Errorf("Blocks this[%v](%v) Not Equal that[%v](%v)", i, this.Blocks[i], i, that1.Blocks[i])
		}
	}
	return nil
}
func (this *INode) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*INode)
	if !ok {
		that2, ok := that.(INode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.INode != that1.INode {
		return false
	}
	if this.Filesize != that1.Filesize {
		return false
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return false
	}
	for i := range this.Attrs {
		if this.Attrs[i] != that1.Attrs[i] {
			return false
		}
	}
	if len(this.Blocks) != len(that1.Blocks) {
		return false
	}
	for i := range this.Blocks {
		if !this.Blocks[i].Equal(that1.Blocks[i]) {
			return false
		}
	}
	return true
}
func (this *BlockLayer) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*BlockLayer)
	if !ok {
		that2, ok := that.(BlockLayer)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *BlockLayer")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *BlockLayer but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *BlockLayer but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return fmt.Errorf("Content this(%v) Not Equal that(%v)", this.Content, that1.Content)
	}
	return nil
}
func (this *BlockLayer) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BlockLayer)
	if !ok {
		that2, ok := that.(BlockLayer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if !bytes.Equal(this.Content, that1.Content) {
		return false
	}
	return true
}
func (this *Volume) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Volume)
	if !ok {
		that2, ok := that.(Volume)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Volume")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Volume but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Volume but is not nil && this == nil")
	}
	if this.Name != that1.Name {
		return fmt.Errorf("Name this(%v) Not Equal that(%v)", this.Name, that1.Name)
	}
	if this.Id != that1.Id {
		return fmt.Errorf("Id this(%v) Not Equal that(%v)", this.Id, that1.Id)
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.MaxBytes != that1.MaxBytes {
		return fmt.Errorf("MaxBytes this(%v) Not Equal that(%v)", this.MaxBytes, that1.MaxBytes)
	}
	return nil
}
func (this *Volume) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Volume)
	if !ok {
		that2, ok := that.(Volume)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.MaxBytes != that1.MaxBytes {
		return false
	}
	return true
}
func (this *PeerInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PeerInfo)
	if !ok {
		that2, ok := that.(PeerInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PeerInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PeerInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PeerInfo but is not nil && this == nil")
	}
	if this.UUID != that1.UUID {
		return fmt.Errorf("UUID this(%v) Not Equal that(%v)", this.UUID, that1.UUID)
	}
	if this.Address != that1.Address {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	if this.LastSeen != that1.LastSeen {
		return fmt.Errorf("LastSeen this(%v) Not Equal that(%v)", this.LastSeen, that1.LastSeen)
	}
	if this.TotalBlocks != that1.TotalBlocks {
		return fmt.Errorf("TotalBlocks this(%v) Not Equal that(%v)", this.TotalBlocks, that1.TotalBlocks)
	}
	if this.UsedBlocks != that1.UsedBlocks {
		return fmt.Errorf("UsedBlocks this(%v) Not Equal that(%v)", this.UsedBlocks, that1.UsedBlocks)
	}
	if this.TimedOut != that1.TimedOut {
		return fmt.Errorf("TimedOut this(%v) Not Equal that(%v)", this.TimedOut, that1.TimedOut)
	}
	if !this.RebalanceInfo.Equal(that1.RebalanceInfo) {
		return fmt.Errorf("RebalanceInfo this(%v) Not Equal that(%v)", this.RebalanceInfo, that1.RebalanceInfo)
	}
	return nil
}
func (this *PeerInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*PeerInfo)
	if !ok {
		that2, ok := that.(PeerInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.UUID != that1.UUID {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.LastSeen != that1.LastSeen {
		return false
	}
	if this.TotalBlocks != that1.TotalBlocks {
		return false
	}
	if this.UsedBlocks != that1.UsedBlocks {
		return false
	}
	if this.TimedOut != that1.TimedOut {
		return false
	}
	if !this.RebalanceInfo.Equal(that1.RebalanceInfo) {
		return false
	}
	return true
}
func (this *RebalanceInfo) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RebalanceInfo)
	if !ok {
		that2, ok := that.(RebalanceInfo)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RebalanceInfo")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RebalanceInfo but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RebalanceInfo but is not nil && this == nil")
	}
	if this.LastRebalanceFinish != that1.LastRebalanceFinish {
		return fmt.Errorf("LastRebalanceFinish this(%v) Not Equal that(%v)", this.LastRebalanceFinish, that1.LastRebalanceFinish)
	}
	if this.LastRebalanceBlocks != that1.LastRebalanceBlocks {
		return fmt.Errorf("LastRebalanceBlocks this(%v) Not Equal that(%v)", this.LastRebalanceBlocks, that1.LastRebalanceBlocks)
	}
	if this.Rebalancing != that1.Rebalancing {
		return fmt.Errorf("Rebalancing this(%v) Not Equal that(%v)", this.Rebalancing, that1.Rebalancing)
	}
	return nil
}
func (this *RebalanceInfo) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*RebalanceInfo)
	if !ok {
		that2, ok := that.(RebalanceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.LastRebalanceFinish != that1.LastRebalanceFinish {
		return false
	}
	if this.LastRebalanceBlocks != that1.LastRebalanceBlocks {
		return false
	}
	if this.Rebalancing != that1.Rebalancing {
		return false
	}
	return true
}
func (this *Ring) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Ring)
	if !ok {
		that2, ok := that.(Ring)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Ring")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Ring but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Ring but is not nil && this == nil")
	}
	if this.Type != that1.Type {
		return fmt.Errorf("Type this(%v) Not Equal that(%v)", this.Type, that1.Type)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if this.ReplicationFactor != that1.ReplicationFactor {
		return fmt.Errorf("ReplicationFactor this(%v) Not Equal that(%v)", this.ReplicationFactor, that1.ReplicationFactor)
	}
	if len(this.Peers) != len(that1.Peers) {
		return fmt.Errorf("Peers this(%v) Not Equal that(%v)", len(this.Peers), len(that1.Peers))
	}
	for i := range this.Peers {
		if !this.Peers[i].Equal(that1.Peers[i]) {
			return fmt.Errorf("Peers this[%v](%v) Not Equal that[%v](%v)", i, this.Peers[i], i, that1.Peers[i])
		}
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return fmt.Errorf("Attrs this(%v) Not Equal that(%v)", len(this.Attrs), len(that1.Attrs))
	}
	for i := range this.Attrs {
		if !bytes.Equal(this.Attrs[i], that1.Attrs[i]) {
			return fmt.Errorf("Attrs this[%v](%v) Not Equal that[%v](%v)", i, this.Attrs[i], i, that1.Attrs[i])
		}
	}
	return nil
}
func (this *Ring) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Ring)
	if !ok {
		that2, ok := that.(Ring)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.ReplicationFactor != that1.ReplicationFactor {
		return false
	}
	if len(this.Peers) != len(that1.Peers) {
		return false
	}
	for i := range this.Peers {
		if !this.Peers[i].Equal(that1.Peers[i]) {
			return false
		}
	}
	if len(this.Attrs) != len(that1.Attrs) {
		return false
	}
	for i := range this.Attrs {
		if !bytes.Equal(this.Attrs[i], that1.Attrs[i]) {
			return false
		}
	}
	return true
}
func (this *BlockRef) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*BlockRef)
	if !ok {
		that2, ok := that.(BlockRef)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *BlockRef")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *BlockRef but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *BlockRef but is not nil && this == nil")
	}
	if this.Volume != that1.Volume {
		return fmt.Errorf("Volume this(%v) Not Equal that(%v)", this.Volume, that1.Volume)
	}
	if this.INode != that1.INode {
		return fmt.Errorf("INode this(%v) Not Equal that(%v)", this.INode, that1.INode)
	}
	if this.Block != that1.Block {
		return fmt.Errorf("Block this(%v) Not Equal that(%v)", this.Block, that1.Block)
	}
	return nil
}
func (this *BlockRef) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*BlockRef)
	if !ok {
		that2, ok := that.(BlockRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.INode != that1.INode {
		return false
	}
	if this.Block != that1.Block {
		return false
	}
	return true
}
func (this *INodeRef) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*INodeRef)
	if !ok {
		that2, ok := that.(INodeRef)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *INodeRef")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *INodeRef but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *INodeRef but is not nil && this == nil")
	}
	if this.Volume != that1.Volume {
		return fmt.Errorf("Volume this(%v) Not Equal that(%v)", this.Volume, that1.Volume)
	}
	if this.INode != that1.INode {
		return fmt.Errorf("INode this(%v) Not Equal that(%v)", this.INode, that1.INode)
	}
	return nil
}
func (this *INodeRef) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*INodeRef)
	if !ok {
		that2, ok := that.(INodeRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.INode != that1.INode {
		return false
	}
	return true
}
func (m *INode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *INode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Volume != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Volume))
	}
	if m.INode != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.INode))
	}
	if m.Filesize != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgro(data, i, uint64(m.Filesize))
	}
	if len(m.Attrs) > 0 {
		for k, _ := range m.Attrs {
			data[i] = 0x3a
			i++
			v := m.Attrs[k]
			mapSize := 1 + len(k) + sovAgro(uint64(len(k))) + 1 + len(v) + sovAgro(uint64(len(v)))
			i = encodeVarintAgro(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgro(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintAgro(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.Blocks) > 0 {
		for _, msg := range m.Blocks {
			data[i] = 0x42
			i++
			i = encodeVarintAgro(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BlockLayer) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BlockLayer) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Type))
	}
	if m.Content != nil {
		if len(m.Content) > 0 {
			data[i] = 0x12
			i++
			i = encodeVarintAgro(data, i, uint64(len(m.Content)))
			i += copy(data[i:], m.Content)
		}
	}
	return i, nil
}

func (m *Volume) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Volume) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgro(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Id != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.Id))
	}
	if len(m.Type) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintAgro(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.MaxBytes != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgro(data, i, uint64(m.MaxBytes))
	}
	return i, nil
}

func (m *PeerInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PeerInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UUID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAgro(data, i, uint64(len(m.UUID)))
		i += copy(data[i:], m.UUID)
	}
	if len(m.Address) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAgro(data, i, uint64(len(m.Address)))
		i += copy(data[i:], m.Address)
	}
	if m.LastSeen != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgro(data, i, uint64(m.LastSeen))
	}
	if m.TotalBlocks != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintAgro(data, i, uint64(m.TotalBlocks))
	}
	if m.UsedBlocks != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintAgro(data, i, uint64(m.UsedBlocks))
	}
	if m.TimedOut {
		data[i] = 0x30
		i++
		if m.TimedOut {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RebalanceInfo != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintAgro(data, i, uint64(m.RebalanceInfo.Size()))
		n1, err := m.RebalanceInfo.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *RebalanceInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RebalanceInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LastRebalanceFinish != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.LastRebalanceFinish))
	}
	if m.LastRebalanceBlocks != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.LastRebalanceBlocks))
	}
	if m.Rebalancing {
		data[i] = 0x18
		i++
		if m.Rebalancing {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Ring) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Ring) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Type))
	}
	if m.Version != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.Version))
	}
	if m.ReplicationFactor != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgro(data, i, uint64(m.ReplicationFactor))
	}
	if len(m.Peers) > 0 {
		for _, msg := range m.Peers {
			data[i] = 0x22
			i++
			i = encodeVarintAgro(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Attrs) > 0 {
		for k, _ := range m.Attrs {
			data[i] = 0x2a
			i++
			v := m.Attrs[k]
			mapSize := 1 + len(k) + sovAgro(uint64(len(k))) + 1 + len(v) + sovAgro(uint64(len(v)))
			i = encodeVarintAgro(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintAgro(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintAgro(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	return i, nil
}

func (m *BlockRef) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *BlockRef) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Volume != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Volume))
	}
	if m.INode != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.INode))
	}
	if m.Block != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintAgro(data, i, uint64(m.Block))
	}
	return i, nil
}

func (m *INodeRef) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *INodeRef) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Volume != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAgro(data, i, uint64(m.Volume))
	}
	if m.INode != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintAgro(data, i, uint64(m.INode))
	}
	return i, nil
}

func encodeFixed64Agro(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Agro(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAgro(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func NewPopulatedINode(r randyAgro, easy bool) *INode {
	this := &INode{}
	this.Volume = uint64(uint64(r.Uint32()))
	this.INode = uint64(uint64(r.Uint32()))
	this.Filesize = uint64(uint64(r.Uint32()))
	if r.Intn(10) != 0 {
		v1 := r.Intn(10)
		this.Attrs = make(map[string]string)
		for i := 0; i < v1; i++ {
			this.Attrs[randStringAgro(r)] = randStringAgro(r)
		}
	}
	if r.Intn(10) != 0 {
		v2 := r.Intn(5)
		this.Blocks = make([]*BlockLayer, v2)
		for i := 0; i < v2; i++ {
			this.Blocks[i] = NewPopulatedBlockLayer(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBlockLayer(r randyAgro, easy bool) *BlockLayer {
	this := &BlockLayer{}
	this.Type = uint32(r.Uint32())
	v3 := r.Intn(100)
	this.Content = make([]byte, v3)
	for i := 0; i < v3; i++ {
		this.Content[i] = byte(r.Intn(256))
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedVolume(r randyAgro, easy bool) *Volume {
	this := &Volume{}
	this.Name = randStringAgro(r)
	this.Id = uint64(uint64(r.Uint32()))
	this.Type = randStringAgro(r)
	this.MaxBytes = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedPeerInfo(r randyAgro, easy bool) *PeerInfo {
	this := &PeerInfo{}
	this.UUID = randStringAgro(r)
	this.Address = randStringAgro(r)
	this.LastSeen = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LastSeen *= -1
	}
	this.TotalBlocks = uint64(uint64(r.Uint32()))
	this.UsedBlocks = uint64(uint64(r.Uint32()))
	this.TimedOut = bool(bool(r.Intn(2) == 0))
	if r.Intn(10) != 0 {
		this.RebalanceInfo = NewPopulatedRebalanceInfo(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRebalanceInfo(r randyAgro, easy bool) *RebalanceInfo {
	this := &RebalanceInfo{}
	this.LastRebalanceFinish = int64(r.Int63())
	if r.Intn(2) == 0 {
		this.LastRebalanceFinish *= -1
	}
	this.LastRebalanceBlocks = uint64(uint64(r.Uint32()))
	this.Rebalancing = bool(bool(r.Intn(2) == 0))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedRing(r randyAgro, easy bool) *Ring {
	this := &Ring{}
	this.Type = uint32(r.Uint32())
	this.Version = uint32(r.Uint32())
	this.ReplicationFactor = uint32(r.Uint32())
	if r.Intn(10) != 0 {
		v4 := r.Intn(5)
		this.Peers = make([]*PeerInfo, v4)
		for i := 0; i < v4; i++ {
			this.Peers[i] = NewPopulatedPeerInfo(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v5 := r.Intn(10)
		this.Attrs = make(map[string][]byte)
		for i := 0; i < v5; i++ {
			v6 := r.Intn(100)
			v7 := randStringAgro(r)
			this.Attrs[v7] = make([]byte, v6)
			for i := 0; i < v6; i++ {
				this.Attrs[v7][i] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedBlockRef(r randyAgro, easy bool) *BlockRef {
	this := &BlockRef{}
	this.Volume = uint64(uint64(r.Uint32()))
	this.INode = uint64(uint64(r.Uint32()))
	this.Block = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedINodeRef(r randyAgro, easy bool) *INodeRef {
	this := &INodeRef{}
	this.Volume = uint64(uint64(r.Uint32()))
	this.INode = uint64(uint64(r.Uint32()))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyAgro interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneAgro(r randyAgro) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringAgro(r randyAgro) string {
	v8 := r.Intn(100)
	tmps := make([]rune, v8)
	for i := 0; i < v8; i++ {
		tmps[i] = randUTF8RuneAgro(r)
	}
	return string(tmps)
}
func randUnrecognizedAgro(r randyAgro, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldAgro(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldAgro(data []byte, r randyAgro, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateAgro(data, uint64(key))
		v9 := r.Int63()
		if r.Intn(2) == 0 {
			v9 *= -1
		}
		data = encodeVarintPopulateAgro(data, uint64(v9))
	case 1:
		data = encodeVarintPopulateAgro(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateAgro(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateAgro(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateAgro(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateAgro(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *INode) Size() (n int) {
	var l int
	_ = l
	if m.Volume != 0 {
		n += 1 + sovAgro(uint64(m.Volume))
	}
	if m.INode != 0 {
		n += 1 + sovAgro(uint64(m.INode))
	}
	if m.Filesize != 0 {
		n += 1 + sovAgro(uint64(m.Filesize))
	}
	if len(m.Attrs) > 0 {
		for k, v := range m.Attrs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgro(uint64(len(k))) + 1 + len(v) + sovAgro(uint64(len(v)))
			n += mapEntrySize + 1 + sovAgro(uint64(mapEntrySize))
		}
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovAgro(uint64(l))
		}
	}
	return n
}

func (m *BlockLayer) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAgro(uint64(m.Type))
	}
	if m.Content != nil {
		l = len(m.Content)
		if l > 0 {
			n += 1 + l + sovAgro(uint64(l))
		}
	}
	return n
}

func (m *Volume) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAgro(uint64(l))
	}
	if m.Id != 0 {
		n += 1 + sovAgro(uint64(m.Id))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAgro(uint64(l))
	}
	if m.MaxBytes != 0 {
		n += 1 + sovAgro(uint64(m.MaxBytes))
	}
	return n
}

func (m *PeerInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.UUID)
	if l > 0 {
		n += 1 + l + sovAgro(uint64(l))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovAgro(uint64(l))
	}
	if m.LastSeen != 0 {
		n += 1 + sovAgro(uint64(m.LastSeen))
	}
	if m.TotalBlocks != 0 {
		n += 1 + sovAgro(uint64(m.TotalBlocks))
	}
	if m.UsedBlocks != 0 {
		n += 1 + sovAgro(uint64(m.UsedBlocks))
	}
	if m.TimedOut {
		n += 2
	}
	if m.RebalanceInfo != nil {
		l = m.RebalanceInfo.Size()
		n += 1 + l + sovAgro(uint64(l))
	}
	return n
}

func (m *RebalanceInfo) Size() (n int) {
	var l int
	_ = l
	if m.LastRebalanceFinish != 0 {
		n += 1 + sovAgro(uint64(m.LastRebalanceFinish))
	}
	if m.LastRebalanceBlocks != 0 {
		n += 1 + sovAgro(uint64(m.LastRebalanceBlocks))
	}
	if m.Rebalancing {
		n += 2
	}
	return n
}

func (m *Ring) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovAgro(uint64(m.Type))
	}
	if m.Version != 0 {
		n += 1 + sovAgro(uint64(m.Version))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovAgro(uint64(m.ReplicationFactor))
	}
	if len(m.Peers) > 0 {
		for _, e := range m.Peers {
			l = e.Size()
			n += 1 + l + sovAgro(uint64(l))
		}
	}
	if len(m.Attrs) > 0 {
		for k, v := range m.Attrs {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAgro(uint64(len(k))) + 1 + len(v) + sovAgro(uint64(len(v)))
			n += mapEntrySize + 1 + sovAgro(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BlockRef) Size() (n int) {
	var l int
	_ = l
	if m.Volume != 0 {
		n += 1 + sovAgro(uint64(m.Volume))
	}
	if m.INode != 0 {
		n += 1 + sovAgro(uint64(m.INode))
	}
	if m.Block != 0 {
		n += 1 + sovAgro(uint64(m.Block))
	}
	return n
}

func (m *INodeRef) Size() (n int) {
	var l int
	_ = l
	if m.Volume != 0 {
		n += 1 + sovAgro(uint64(m.Volume))
	}
	if m.INode != 0 {
		n += 1 + sovAgro(uint64(m.INode))
	}
	return n
}

func sovAgro(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAgro(x uint64) (n int) {
	return sovAgro(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *INode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: INode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: INode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Volume |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field INode", wireType)
			}
			m.INode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.INode |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filesize", wireType)
			}
			m.Filesize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Filesize |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgro
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapvalue uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapvalue |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapvalue := int(stringLenmapvalue)
			if intStringLenmapvalue < 0 {
				return ErrInvalidLengthAgro
			}
			postStringIndexmapvalue := iNdEx + intStringLenmapvalue
			if postStringIndexmapvalue > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := string(data[iNdEx:postStringIndexmapvalue])
			iNdEx = postStringIndexmapvalue
			if m.Attrs == nil {
				m.Attrs = make(map[string]string)
			}
			m.Attrs[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &BlockLayer{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockLayer) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], data[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Volume) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Volume: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Volume: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Id |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBytes", wireType)
			}
			m.MaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MaxBytes |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UUID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeen", wireType)
			}
			m.LastSeen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastSeen |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBlocks", wireType)
			}
			m.TotalBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalBlocks |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedBlocks", wireType)
			}
			m.UsedBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UsedBlocks |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimedOut", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TimedOut = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebalanceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RebalanceInfo == nil {
				m.RebalanceInfo = &RebalanceInfo{}
			}
			if err := m.RebalanceInfo.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RebalanceInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RebalanceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RebalanceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRebalanceFinish", wireType)
			}
			m.LastRebalanceFinish = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastRebalanceFinish |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRebalanceBlocks", wireType)
			}
			m.LastRebalanceBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastRebalanceBlocks |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rebalancing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Rebalancing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ring) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ring: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ring: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReplicationFactor |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers, &PeerInfo{})
			if err := m.Peers[len(m.Peers)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attrs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAgro
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthAgro
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthAgro
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Attrs == nil {
				m.Attrs = make(map[string][]byte)
			}
			m.Attrs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRef) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Volume |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field INode", wireType)
			}
			m.INode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.INode |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			m.Block = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Block |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *INodeRef) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: INodeRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: INodeRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			m.Volume = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Volume |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field INode", wireType)
			}
			m.INode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.INode |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAgro(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAgro
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAgro(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAgro
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAgro
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAgro
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAgro
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAgro(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAgro = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAgro   = fmt.Errorf("proto: integer overflow")
)
